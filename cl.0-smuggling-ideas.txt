james kettle's request smuggler does not account for all CL.0 desync vectors. 

Specifically it does not account for GET request based smuggling using obfuscated CL headers (using the same obfuscation techniques as TE). CL.0 smuggling can also happen when invalid headers trigger a server error eg 400. occasionally when this happens the server does not consume the body of the request or closing the connection. 

2 methods: both apply to HTTP/1.1 and HTTP/2 so long as its downgraded on the backend

	- GET w/ obfuscated CL header 
	- 400 error immediatly followed by valid request
	
** learn more about how CL.0 and TE.0 work try to discern what http methods/ obfuscation techniques could be useful. Very hard to say   as 
there is barely any research. Still look at James Kettles posts on TE.0 and why he didnt think it would work. Will also need to learn 
a bit more about HTTP methods what exactly the differences are and if there are differences in H1 vs H2 concerning methods. Try to use 
this to inform the tests we implement. Again hard bc theres no research so we will kind of have to just test things out manually and 
through the program and change stuff accordingly. 

** still have to learn about CRLF and different potential techniques for getting it. Should implement CRLF checks as James described in 
one of the bookmarked articles. if found we should test CRLF based smuggling payloads. Comprehensive CRLF checks would be awesome so do 
research into different possible attack vectors for CRLF. 

**also have to check for response splitting as this can likely be bypassed. Any split responses should be printed immediatly and then 
should be tested manually. 


**************************************
implement a giant header as detailed in the obfuscation and payloads notes!! we will have to write some code to make this, the 
header is absolutely giant. it just involves a header with a TON of repeated characters:
X: ==============( 65 532 '=' )========================\r\n

ex: (i believe we dont even use CL or TE headers **will have to review original article to check):
GET_/something.html?zorg=6_HTTP/1.1\r\n
Host:_dummy-host7.example.com\r\n
X:_"%65532s"\r\n		//REPLACE THIS LINE W/ GIANT HEADER CONTAINING 65532 = chars
GET_http://dummy-host7.example.com/index.html?replaced=0&cache=8_HTTP/1.1\r\n
\r\n
**************************************

**************************************
DOUBLE CL HEADERS!!!
GET /index.html?toto=1 HTTP/1.1\r\n
Host: dummy-host7.example.com\r\n
Content-Length: 0\r\n
Content-Length: 66\r\n
\r\n
GET /index.html?toto=2 HTTP/1.1\r\n
Host: dummy-host7.example.com\r\n
\r\n
**************************************

**** JAMES KETTLE NOTES (only useful for manual stuff -> put in our notes somewhere):

*this one is important for mnaual testing
Next, recall you can only poison requests that are routed to the same back-end server. Since routing might be based on the request 
cookie, path, method or any other request property you should start with a 'victim' request that's near-identical to the attack 
request, then change each value and retry the attack in turn until the victim request resembles a regular GET request sent by another user.

If the regular GET request is still getting poisoned but you can't exploit other users, or the vulnerability is only visible 
intermittently, one possibility is that the target has multiple front-end servers and only some of them are vulnerable. You can 
explore this possibility using dig.Finally, the front-end's connection reuse might be tied to your IP. To explore this, try sending
the victim requests from a different IP. If you find you're genuinely only able to affect requests from your own IP, the practical
impact is limited to exploiting other people on the same corporate network... or direct attacks like the one I demonstrated on New Relic.





